const Utils = (() => {
    /**
     * @param {object} target The object that is store data
     * @param {object} resorce The object that need passing data to target
     * @returns {object} The object is merged
     */
    function merge(target, resorce) {
        for (let i in resorce) {
            if (
                i in target &&
                typeof resorce[i] === 'object' &&
                typeof target[i] === 'object'
            ) {
                merge(target[i], resorce[i]);
                continue;
            }
            target[i] = resorce[i];
        }
        return target;
    };

    function debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => { func.apply(this, args) }, timeout);
        };
    }

    function throttle(func, timeout = 300) {
        let lastTime = 0;
        return (...args) => {
            let now = Date.now();
            if (now - lastTime >= timeout) {
                func.apply(this, args);
                lastTime = now;
            }
        }
    }

    function getParamsURL(str) {
        const prm = decodeURIComponent(decodeURIComponent(new URLSearchParams(location.search).get(str)));
        return prm === 'null' ? null : prm;
    }

    /**
     * @param {string} field The name of params that you want to change the value.
     * @param {string | number} value The value must be change.
     */
    function changeParamsURL(field, value) {
        const url = new URL(window.location);
        url.searchParams.set(field, value);
        const newUrl = url.toString().replace(/\+/g, '%20');
        window.history.pushState({}, '', newUrl);
    }

    /**
     * 
     * @param {any} val Giá trị bất kỳ
     */
    function fixNullish(val) {
        return val ?? 'N/A';
    }

    function vhToPx(vh) {
        const vhInPx = window.innerHeight / 100;
        return vh * vhInPx;
    }

    function vwToPx(vw) {
        const vwInPx = window.innerWidth / 100;
        return vw * vwInPx;
    }

    /**
 * Groups an array of objects by a specified key.
 *
 * @template T - The type of objects in the array.
 * @template K - The key of the object to group by.
 * @param {T[]} xs - The array of objects to group.
 * @param {K} key - The key to group the objects by.
 * @returns {Record<string, T[]>} An object where the keys are the values of the specified key in the objects, 
 * and the values are arrays of objects that have that key value.
 * @throws {Error} If the input array is not provided.
 */
 const groupBy = (xs, key) => {
    if(!xs) {
        throw new Error("Can't group array because input is not array");
    }
    return xs.reduce((rv, x) => {
        const keyValue = x[key];
        (rv[keyValue] = rv[keyValue] || []).push(x);
        return rv;
    }, {});
    };

    /**
     * @param {number} num 
     */
    function secondsToHours(num) {
        if(isNaN(num) || num === 0) {
            return 0;
        }
        return num / 60 /*minutesInSeconds*/ / 60 /*hoursInMinus*/;
    }

    /**
     * @param {number} num 
     */
    function minutesToHours(num) {
        if(isNaN(num) || num === 0) {
            return 0;
        }
        return num / 60 /*hoursInMinus*/;
    }

    function formatNum(num , {
        minimumFractionDigits = 2,
        maximumFractionDigits = 2,
        locales = 'en-US'
    }) {
        const formatter = new Intl.NumberFormat('en-US', {
            minimumFractionDigits,
            maximumFractionDigits,
        });
        return Number(formatter.format(num));
    }

    /**
     * @type {Array<() => void>}
     */
    const domContentLoadedCallbacks = [];

    /**
     * 
     * @param {() => void} callback 
     */
    const onDOMContentLoaded = (callback) => {
        if(document.readyState === 'loading') {
            // Đăng ký một hàm xử lý sự kiện khi tài liệu trong trạng thái đang tải
            if(!domContentLoadedCallbacks.length) {
                document.addEventListener('DOMContentLoaded', () => {
                    for (const callback of domContentLoadedCallbacks) {
                        callback();
                    }
                })
            }
        }
    }

    /* ES2022 UTILITY FUNCTIONS */

    /**
     * Kiểm tra xem một phần tử có một thuộc tính dữ liệu nhất định hay không sử dụng Object.hasOwn()
     * @param {HTMLElement} element
     * @param {string} attribute
     */
    const hasDataAttribute = (element, attribute) => {
        return Object.hasOwn(element.dataset, attribute);
    }

    const getLastElement = (elements) => {
        const elementsArray = Array.from(elements);
        return elementsArray.at(-1);
    }

    /**
     * Truy cập thuoojtcj tính một cách an toàn với xử lý lỗi
     */
    const safePropertyAccess = (obj, property) => {
        try {
            return Object.hasOwn(obj, property) ? obj[property] : undefined;
        } catch (error) {
            throw new Error(`Failed to access property '${property}'`, { cause: error });
        }
    }

    return {
        debounce,
        throttle,
        getParamsURL,
        changeParamsURL,
        merge,
        fixNullish,
        vhToPx,
        vwToPx,
        groupBy,
        secondsToHours,
        formatNum,
        minutesToHours,
        hasDataAttribute,
        getLastElement,
        safePropertyAccess,
    }
})();

export default Utils;